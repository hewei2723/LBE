C51 COMPILER V9.60.7.0   MAIN                                                              11/10/2024 16:47:31 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg51.h>
   2          sbit LE = P1 ^ 0;
   3          sbit key1 = P2 ^ 0;
   4          sbit key2 = P2 ^ 1;
   5          sbit key3 = P2 ^ 2;
   6          sbit key4 = P2 ^ 3;
   7          int cp = 0, cpfh = 0;time = 0, flash = 0x00, start = 1, mode = 0;
   8          int secondA, hourA, minuteA, secondB, minuteB, hourB;
   9          int poi[] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};
  10          unsigned char seven_seg[] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90};
  11          int sno[]={1,1,6,0,1,0,2,2};
  12          void key();
  13          void latch()
  14          {
  15   1        LE = 1;
  16   1        LE = 0;
  17   1      }
  18          void delay(int x)
  19          {
  20   1        while (x--);
  21   1      }
  22          void STM(int time)
  23          {
  24   1        secondA = (time % 60) / 10;
  25   1        secondB = (time % 60) % 10;
  26   1        minuteA = (time / 60 % 60) / 10;
  27   1        minuteB = (time / 60 % 60) % 10;
  28   1        hourA = (time / 3600) / 10;
  29   1        hourB = (time / 3600) % 10;
  30   1      }
  31          void showSno(){
  32   1        int i;
  33   1        for(i=0;i<8;i++){
  34   2        P0 = 0xff;P0 = poi[i];latch();P0 = seven_seg[sno[i]];delay(300);
  35   2        }
  36   1      }
  37          void timer0_isr() interrupt 1
  38          {
  39   1        TH0 = (65535 - 5000) / 256;
  40   1        TL0 = (65535 - 5000) % 256;
  41   1        cp++;
  42   1        cpfh++;
  43   1        if (cp > 25 && start == 1)
  44   1        {
  45   2          time++;
  46   2          cp = 0;
  47   2        }
  48   1        if (cpfh > 25)
  49   1        {
  50   2          flash = ~flash;
  51   2          cpfh = 0;
  52   2        }
  53   1        STM(time);
  54   1        if(time<1){
C51 COMPILER V9.60.7.0   MAIN                                                              11/10/2024 16:47:31 PAGE 2   

  55   2        showSno();}else{key();}
  56   1      
  57   1      }
  58          void timer0_init()
  59          {
  60   1        TMOD = 0x01;
  61   1        TH0 = (65536 - 5000) / 256;
  62   1        TL0 = (65536 - 5000) % 256;
  63   1        EA = 1;
  64   1        ET0 = 1;
  65   1        TR0 = 1;
  66   1      }
  67          void display(int num, int Poi)
  68          {
  69   1        P0 = 0xff;P0 = poi[Poi];latch();P0 = seven_seg[num];delay(300);
  70   1        P0 = 0xff;P0 = 0X04;latch();P0 = 0xbf | flash;delay(100);
  71   1        P0 = 0xff;P0 = 0X20;latch();P0 = 0xbf | flash;delay(100);
  72   1      }
  73          void Modedisplay(int num, int Poi)
  74          {
  75   1        P0 = 0xff;P0 = poi[Poi];latch();P0 = seven_seg[num] | flash;delay(300);
  76   1        P0 = 0xff;P0 = 0X04;latch();P0 = 0xbf;delay(100);
  77   1        P0 = 0xff;P0 = 0X20;latch();P0 = 0xbf;delay(100);
  78   1      }
  79          void ShowTime(int num, int mode)//mode=0 ++ mode=1 +60 mode =2 +3600
  80          { // num管理哪一个闪动，mode=0的时候调整模式
  81   1        if (num == 0)
  82   1        {
  83   2          if (mode)
  84   2          {
  85   3            Modedisplay(secondA, 1);
  86   3            Modedisplay(secondB, 0);
  87   3          }
  88   2          else
  89   2          {
  90   3            display(secondA, 1);
  91   3            display(secondB, 0);
  92   3          }
  93   2        }
  94   1        else if (num == 1)
  95   1        {
  96   2          if (mode)
  97   2          {
  98   3            Modedisplay(minuteA, 4);
  99   3            Modedisplay(minuteB, 3);
 100   3          }
 101   2          else
 102   2          {
 103   3            display(minuteA, 4);
 104   3            display(minuteB, 3);
 105   3          }
 106   2        }
 107   1        else if (num == 2)
 108   1        {
 109   2          if (mode)
 110   2          {
 111   3            Modedisplay(hourA, 7);
 112   3            Modedisplay(hourB, 6);
 113   3          }
 114   2          else
 115   2          {
 116   3            display(hourA, 7);
C51 COMPILER V9.60.7.0   MAIN                                                              11/10/2024 16:47:31 PAGE 3   

 117   3            display(hourB, 6);
 118   3          }
 119   2        }
 120   1      }
 121          void changeTime()
 122          {
 123   1        int s;
 124   1        static int keyS2 = 1, keyS3 = 1; // 按键状态
 125   1        switch (mode)
 126   1        {
 127   2        case 0:
 128   2          s = 1;
 129   2          break;
 130   2        case 1:
 131   2          s = 60;
 132   2          break;
 133   2        case 2:
 134   2          s = 3600;
 135   2          break;
 136   2        }
 137   1        if (keyS2 == 1 && key2 == 0)  // 按键2按下并检测状态
 138   1        {
 139   2          delay(200);  // 消抖延时
 140   2          if (key2 == 0) // 确认按键仍然按下
 141   2          {
 142   3            time += s;
 143   3            keyS2 = 0;  // 置为0，防止重复触发
 144   3          }
 145   2        }
 146   1        else if (key2 == 1) // 按键松开后重置状态
 147   1        {
 148   2          keyS2 = 1;
 149   2        }
 150   1        if (keyS3 == 1 && key3 == 0) // 按键3按下并检测状态
 151   1        {
 152   2          delay(200);  // 消抖延时
 153   2          if (key3 == 0) // 确认按键仍然按下
 154   2          {
 155   3            time -= s;
 156   3            keyS3 = 0;  // 置为0，防止重复触发
 157   3          }
 158   2        }
 159   1        else if (key3 == 1) // 按键松开后重置状态
 160   1        {
 161   2          keyS3 = 1;
 162   2        }
 163   1      }
 164          
 165          void key(){
 166   1        int keyL=1;
 167   1        if(start){
 168   2          ShowTime(0,0);
 169   2          ShowTime(1,0);
 170   2          ShowTime(2,0);
 171   2        }
 172   1        //按下按钮1，模式变化,start变成0
 173   1        if(keyL==1&&key1==0){
 174   2          start=0;
 175   2          delay(100);
 176   2          //按一次选择一次模式
 177   2          if(key1==0){
 178   3          mode=(mode+1)%3;//按下一次mode值变化一次，从0，1，2循环变化
C51 COMPILER V9.60.7.0   MAIN                                                              11/10/2024 16:47:31 PAGE 4   

 179   3          }
 180   2          keyL=key1;
 181   2          delay(100);
 182   2        }
 183   1        keyL=1;
 184   1        if(!start){//如果当前是暂停状态
 185   2          if(mode==0)//秒闪动
 186   2            {
 187   3          ShowTime(0,1);
 188   3          ShowTime(1,0);
 189   3          ShowTime(2,0);
 190   3          changeTime();
 191   3            }
 192   2          if(mode==1)//分闪动
 193   2            {
 194   3          ShowTime(0,0);
 195   3          ShowTime(1,1);
 196   3          ShowTime(2,0);
 197   3          changeTime();
 198   3            }
 199   2          if(mode==2)//小时闪动
 200   2            {
 201   3          ShowTime(0,0);
 202   3          ShowTime(1,0);
 203   3          ShowTime(2,1);
 204   3          changeTime();
 205   3            }
 206   2        }
 207   1        if(key4==0){//按下按钮4，继续执行
 208   2          start=1;
 209   2        }
 210   1      }
 211          void main()
 212          {
 213   1        timer0_init();
 214   1        while (1);
 215   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    995    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     70       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
